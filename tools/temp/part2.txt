    const result: Record<string, any> = {};
    settings.forEach(s => { result[s.key] = { value: s.value, lms: s.lms, storage: s.storage, security: s.security }; });
    res.json(result);
  }));

  app.put('/api/admin/system-settings', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const updates = req.body as Record<string, any>;
    if (!updates || typeof updates !== 'object') {
      return res.status(400).json({ message: 'Invalid request body' });
    }
    const user = req.user as User;
    const result: Record<string, any> = {};
    for (const key of Object.keys(updates)) {
      const value = updates[key];
      const settingPayload: any = { key, value: value.value ?? value, updatedBy: user.id };
      if (value.lms !== undefined) settingPayload.lms = value.lms;
      if (value.storage !== undefined) settingPayload.storage = value.storage;
      if (value.security !== undefined) settingPayload.security = value.security;

      const setting = await storage.upsertSystemSetting(settingPayload);
      result[setting.key] = { value: setting.value, lms: setting.lms, storage: setting.storage, security: setting.security };
    }
    res.json(result);
  }));

  app.post('/api/admin/security-audit', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const user = req.user as User;
    await queueSecurityAudit(user.id);
    res.json({ message: 'Security audit queued' });
  }));

  // Newsletter subscription
  app.post('/api/newsletter/subscribe', asyncHandler(async (req: Request, res: Response) => {
    const schema = z.object({ email: z.string().email() });
    const result = schema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid email address' });
    }

    const { email } = result.data;

    try {
      const existing = await db.select().from(newsletterSubscribers).where(eq(newsletterSubscribers.email, email));
      if (existing.length > 0) {
        return res.status(200).json({ message: 'Already subscribed' });
      }

      await db.insert(newsletterSubscribers).values({ email }).returning();
      return res.status(201).json({ message: 'Subscribed' });
    } catch (error) {
      console.error('Failed to subscribe to newsletter:', error);
      return res.status(500).json({ message: 'Failed to subscribe' });
    }
  }));
  // Authentication endpoints handled in auth.ts

  // Admin user management (from codex/add-admin-user-routes-and-connect-to-storage branch)
  app.get('/api/admin/users', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const usersList = await storage.listUsers();
    res.json(usersList);
  }));

  app.post('/api/admin/users', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const userSchema = z.object({
      name: z.string().min(1),
      username: z.string().min(3),
      email: z.string().email(),
      password: z.string().min(6).optional(),
      role: z.enum(['student', 'instructor', 'admin']).default('student'),
    });

    const result = userSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid user data', errors: result.error.format() });
    }

    const { password, ...data } = result.data;
    const newUser = await storage.createUser({ ...data, password: password ?? null });
    res.status(201).json(newUser);
  }));

  app.put('/api/admin/users/:id', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    const updateSchema = z.object({
      name: z.string().optional(),
      username: z.string().optional(),
      email: z.string().email().optional(),
      password: z.string().min(6).optional(),
      role: z.enum(['student', 'instructor', 'admin']).optional(),
    });

    const result = updateSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid user data', errors: result.error.format() });
    }

    const updated = await storage.updateUser(userId, result.data);
    if (!updated) {
      return res.status(404).json({ message: 'User not found' });
    }

    res.json(updated);
  }));

  app.delete('/api/admin/users/:id', requireAuth, requireRole('admin'), asyncHandler(async (req: Request, res: Response) => {
    const userId = parseInt(req.params.id);
    if (isNaN(userId)) {
      return res.status(400).json({ message: 'Invalid user ID' });
    }

    await storage.deleteUser(userId);
    res.status(204).end();
  }));

  // User notification settings (from origin/main branch)
  app.get('/api/user/notifications', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const user = req.user as User;
    const settings = await storage.getUserNotificationSettings(user.id);
    if (!settings) {
      return res.json({
        emailNotifications: true,
        assignmentNotifications: true,
        feedbackNotifications: true,
        systemNotifications: false
      });
    }
    res.json(settings);
  }));

  app.put('/api/user/notifications', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const user = req.user as User;
    const schema = z.object({
      emailNotifications: z.boolean(),
      assignmentNotifications: z.boolean(),
      feedbackNotifications: z.boolean(),
      systemNotifications: z.boolean(),
    });

    const result = schema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid settings', errors: result.error.flatten() });
    }

    const settings = await storage.upsertUserNotificationSettings({
      userId: user.id,
      ...result.data,
    });

    res.json(settings);
  }));

  // MFA endpoints (from origin/main branch)
  app.get('/api/mfa/setup', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const user = req.user as any; // Assuming user object has id and username
    const secret = generateSecret();
    const url = generateOtpAuthUrl(secret, user.username); // Ensure user.username exists
    await storage.updateUserMfa(user.id, false, secret); // Make sure storage.updateUserMfa handles these params
    res.json({ secret, url });
  }));

  app.post('/api/mfa/enable', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const { token } = req.body;
    const user = await storage.getUser((req.user as any).id);
    if (!user || !user.mfaSecret) {
      return res.status(400).json({ message: 'MFA not initialized' });
    }
    if (!token || !verifyTotp(String(token), user.mfaSecret)) {
      return res.status(401).json({ message: 'Invalid MFA token' });
    }
    await storage.updateUserMfa(user.id, true, user.mfaSecret);
    res.json({ enabled: true });
  }));

  app.post('/api/mfa/disable', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const { token } = req.body;
    const user = await storage.getUser((req.user as any).id);
    if (!user || !user.mfaSecret) { // Should check if MFA is enabled rather than just secret exists
      return res.status(400).json({ message: 'MFA not enabled' });
    }
    if (!token || !verifyTotp(String(token), user.mfaSecret)) {
      return res.status(401).json({ message: 'Invalid MFA token' });
    }
    await storage.updateUserMfa(user.id, false, null); // Setting secret to null on disable
    res.json({ enabled: false });
  }));

  // Assignment endpoints
  app.get('/api/assignments', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const user = req.user as any;
    let assignments;

    if (user.role === 'student') {
      assignments = await storage.listAssignmentsForUser(user.id);

      // For each assignment, get the latest submission
      const assignmentsWithSubmissions = await Promise.all(
        assignments.map(async (assignment) => {
          const submission = await storage.getLatestSubmission(user.id, assignment.id);
          const course = await storage.getCourse(assignment.courseId);
          return {
            ...assignment,
            submissions: submission ? [submission] : [],
            course
          };
        })
      );

      res.json(assignmentsWithSubmissions);
    } else {
      // For instructors, return all assignments with submission counts
      assignments = await storage.listAssignments();

      const assignmentsWithStats = await Promise.all(
        assignments.map(async (assignment) => {
          const submissions = await storage.listSubmissionsForAssignment(assignment.id);
          const course = await storage.getCourse(assignment.courseId);
          const students = await storage.listCourseEnrollments(assignment.courseId);

          const submittedCount = new Set(submissions.map(s => s.userId)).size;

          return {
            ...assignment,
            submittedCount,
            totalStudents: students.length,
            submissionPercentage: students.length > 0 ? (submittedCount / students.length) * 100 : 0,
            course
          };
        })
      );

      res.json(assignmentsWithStats);
    }
  }));

  // Get specific assignment
  app.get('/api/assignments/:id', requireAuth, asyncHandler(async (req: Request, res: Response) => {
    const assignmentId = parseInt(req.params.id);
    const assignment = await storage.getAssignment(assignmentId);

    if (!assignment) {
      return res.status(404).json({ message: 'Assignment not found' });
    }

    const course = await storage.getCourse(assignment.courseId);

    res.json({
      ...assignment,
      course
    });
  }));

  // Create assignment (instructor only)
  app.post('/api/assignments', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
    try {
      const { title, description, courseId, dueDate, rubric } = req.body;

      console.log("Creating assignment with data:", JSON.stringify({
        title,
        description: description?.substring(0, 30) + "...",
        courseId,
        dueDate
      }));

      // Validate request
      const assignmentSchema = z.object({
        title: z.string().min(3),
        description: z.string().min(10),
        courseId: z.union([
          z.number().int().positive(),
          z.string().transform(val => parseInt(val))
        ]).optional(), // Make optional for standalone assignments
        dueDate: z.string().refine(val => !isNaN(Date.parse(val)), {
          message: 'Invalid date format'
        }),
        rubric: z.object({
          criteria: z.array(z.object({
            id: z.string(),
            type: z.string(),
            name: z.string(),
            description: z.string(),
            maxScore: z.number().int().min(1),
            weight: z.number().int().min(1),
          })).optional(),
          totalPoints: z.number().int().positive().optional(),
          passingThreshold: z.number().int().min(0).max(100).optional(),
        }).optional(),
      });

      const result = assignmentSchema.safeParse(req.body);
      if (!result.success) {
        const errorDetails = JSON.stringify(result.error.format());
        console.error("Assignment validation failed:", errorDetails);
        return res.status(400).json({
          message: 'Invalid assignment data',
          errors: result.error.format()
        });
      }

      // Check if course exists (if courseId is provided)
      if (courseId) {
        const courseIdNum = typeof courseId === 'string' ? parseInt(courseId) : courseId;
        const course = await storage.getCourse(courseIdNum);
        if (!course) {
          return res.status(404).json({ message: 'Course not found' });
        }
      }

      // Generate a unique shareable code
      const shareableCode = generateShareableCode();

      // Create assignment
      const courseIdNum = courseId ? (typeof courseId === 'string' ? parseInt(courseId) : courseId) : undefined;
      const assignment = await storage.createAssignment({
        title,
        description,
        courseId: courseIdNum,
        dueDate: new Date(dueDate),
        status: 'active',
        shareableCode,
        rubric: rubric ? JSON.stringify(rubric) as any : null,
      });

      console.log("Assignment created successfully, ID:", assignment.id);
      return res.status(201).json(assignment);
    } catch (error) {
      console.error("Error creating assignment:", error);
      return res.status(500).json({
        message: 'Failed to create assignment',
        error: error instanceof Error ? error.message : String(error)
      });
    }
  }));

  // Get assignment details for instructor
  app.get('/api/assignments/:id/details', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
    const assignmentId = parseInt(req.params.id);
    let assignment;
    try {
      assignment = await storage.getAssignment(assignmentId);
    } catch (err) {
      console.error('Error retrieving assignment:', err);
      const assignments = await storage.listAssignments();
      assignment = assignments.find(a => a.id === assignmentId);

      if (!assignment) {
        return res.status(404).json({ message: 'Assignment not found' });
      }
    }

    if (!assignment) {
      return res.status(404).json({ message: 'Assignment not found' });
    }

    let course = null;
    let submissions: any[] = [];
    let students: any[] = [];

    try {
      course = await storage.getCourse(assignment.courseId);
    } catch (err) {
      console.error('Error fetching course:', err);
    }

    try {
      submissions = await storage.listSubmissionsForAssignment(assignment.id);
    } catch (err) {
      console.error('Error fetching submissions:', err);
    }

    try {
      students = await storage.listCourseEnrollments(assignment.courseId);
    } catch (err) {
      console.error('Error fetching students:', err);
    }

    const submittedCount = submissions.length > 0 ? new Set(submissions.map(s => s.userId)).size : 0;

    let shareableCode = assignment.shareableCode;
    if (!shareableCode && assignment.id) {
      shareableCode = generateShareableCode();
      try {
        await storage.updateAssignmentShareableCode(assignment.id, shareableCode);
      } catch (err) {
        console.error('Error updating assignment with shareable code:', err);
      }
    }

    res.json({
      ...assignment,
      course,
      submittedCount,
      totalStudents: students.length,
      submissionPercentage: students.length > 0 ? (submittedCount / students.length) * 100 : 0,
      shareableCode: shareableCode || 'temp-' + assignment.id
    });
  }));

  app.patch('/api/assignments/:id/status', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
    const assignmentId = parseInt(req.params.id);

    if (isNaN(assignmentId)) {
      return res.status(400).json({ message: 'Invalid assignment ID' });
    }

    const statusSchema = z.object({
      status: z.enum(['active', 'upcoming', 'completed'])
    });

    const result = statusSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid status value', errors: result.error });
    }

    const { status } = result.data;

    const assignment = await storage.getAssignment(assignmentId);
    if (!assignment) {
      return res.status(404).json({ message: 'Assignment not found' });
    }

    const updatedAssignment = await storage.updateAssignmentStatus(assignmentId, status);

    res.json(updatedAssignment);
  }));

  app.get('/api/assignments/code/:code', defaultRateLimiter, asyncHandler(async (req: Request, res: Response) => {
    const code = req.params.code;

    console.log(`Looking up assignment with code: ${code}`);

    if (!code || code.length < 6) {
      console.log(`Invalid shareable code: ${code}`);
      return res.status(400).json({ message: 'Invalid shareable code' });
    }

    const assignments = await storage.listAssignments();
    console.log(`Found ${assignments.length} assignments total`);

    const allCodes = assignments
      .filter(a => a.shareableCode)
      .map(a => ({ id: a.id, code: a.shareableCode }));
    console.log(`Available shareable codes:`, JSON.stringify(allCodes));

    const assignment = assignments.find(a =>
      a.shareableCode && a.shareableCode.toLowerCase() === code.toLowerCase());

    if (!assignment) {
      return res.status(404).json({ message: 'Assignment not found with this code' });
    }

    const course = await storage.getCourse(assignment.courseId);

    if (!course) {
      return res.status(404).json({ message: 'Course not found for this assignment' });
    }

    const isAuthenticated = req.isAuthenticated();

    let shareableCode = assignment.shareableCode;

    if (!shareableCode && assignment.id) {
      shareableCode = generateShareableCode();
      try {
        await storage.updateAssignmentShareableCode(assignment.id, shareableCode);
        console.log(`Generated new shareable code ${shareableCode} for assignment ${assignment.id}`);
      } catch (err) {
        console.error('Error updating assignment with new shareable code:', err);
      }
    }

    res.json({
      id: assignment.id,
      title: assignment.title,
      description: assignment.description,
      courseId: assignment.courseId,
      courseCode: course.code,
      courseName: course.name,
      dueDate: assignment.dueDate,
      shareableCode: shareableCode || `TEMP-${assignment.id}`,
      requiresAuth: true,
      isAuthenticated: isAuthenticated
    });
  }));

  app.post('/api/anonymous-submissions', submissionRateLimiter, requireAuth, upload.single('file'), asyncHandler(async (req: Request, res: Response) => {
    const submissionSchema = z.object({
      assignmentId: z.string().transform(val => parseInt(val)),
      submissionType: z.enum(['file', 'code']),
      name: z.string().min(1),
      email: z.string().email(),
      notes: z.string().optional(),
      code: z.string().optional(),
      shareableCode: z.string().min(1, "Shareable code is required for anonymous submissions"),
    });

    const result = submissionSchema.safeParse(req.body);
    if (!result.success) {
      return res.status(400).json({ message: 'Invalid submission data', errors: result.error });
    }

    const { assignmentId, submissionType, name, email, notes, code, shareableCode } = result.data;

    const assignment = await storage.getAssignment(assignmentId);

    if (!assignment) {
      return res.status(404).json({ message: 'Assignment not found' });
    }

    let storedShareableCode = assignment.shareableCode;

    if (!storedShareableCode && assignment.id) {
      storedShareableCode = generateShareableCode();
      try {
        await storage.updateAssignmentShareableCode(assignment.id, storedShareableCode);
        console.log(`Generated new shareable code ${storedShareableCode} for assignment ${assignment.id}`);
      } catch (err) {
        console.error('Error updating assignment with new shareable code:', err);
      }
    }

    if (!storedShareableCode) {
      storedShareableCode = `TEMP-${assignment.id}`;
    }

    if (shareableCode !== storedShareableCode) {
      return res.status(403).json({ message: 'Invalid shareable code' });
    }

    const userId = req.user ? (req.user as any).id : 0;

    let submission: any = {
      assignmentId,
      userId,
      name,
      email,
      status: 'submitted',
      notes,
      contentType: null,
      fileSize: null,
      fileName: null,
      fileExtension: null,
      submissionType
    };

    if (submissionType === 'file') {
      if (!req.file) {
        return res.status(400).json({ message: 'No file uploaded' });
      }

      const extension = path.extname(req.file.originalname).toLowerCase().slice(1);
      const mimeType = req.file.mimetype;
      const contentType = determineContentType(mimeType, req.file.originalname);

      if (!contentType || !isFileTypeAllowed(extension, contentType)) {
        return res.status(400).json({
          message: `File type .${extension} is not allowed`,
          allowedTypes: SUPPORTED_MIME_TYPES
        });
      }

      submission.contentType = contentType;
      submission.fileSize = req.file.size;
      submission.fileName = req.file.originalname;
      submission.fileExtension = extension;
      submission.content = req.file.buffer.toString('base64');
    } else if (submissionType === 'code') {
      if (!code) {
        return res.status(400).json({ message: 'Code content is required for code submissions' });
      }

      submission.contentType = 'text';
      submission.content = code;
      submission.fileExtension = 'txt';
    } else {
      return res.status(400).json({ message: 'Invalid submission type' });
    }

    const createdSubmission = await storage.createSubmission(submission);

    await submissionQueue.add('process', {
      submissionId: createdSubmission.id,
      assignmentId: assignmentId,
      userId: userId,
      submissionType: submissionType,
      contentType: submission.contentType,
      content: submission.content,
      fileName: submission.fileName,
      fileExtension: submission.fileExtension,
    });

    res.status(201).json({
      id: createdSubmission.id,
      message: 'Submission added successfully and queued for processing'
    });
  }));

  app.post('/api/submissions', requireAuth, upload.single('file'), asyncHandler(async (req: Request, res: Response) => {
      const user = req.user as any;

      if (user.role !== 'student') {
        return res.status(403).json({ message: 'Only students can submit assignments' });
      }

      const submissionSchema = z.object({
        assignmentId: z.string().transform(val => parseInt(val)),
        submissionType: z.enum(['file', 'code']),
        notes: z.string().optional()
      });

      const result = submissionSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: 'Invalid submission data', errors: result.error });
      }

      const { assignmentId, submissionType, notes } = result.data;

      const isActive = await storageService.isAssignmentActive(assignmentId);
      if (!isActive) {
        return res.status(400).json({ message: 'Assignment is not active or has passed its due date' });
      }

      const isEnrolled = await storageService.isStudentEnrolled(user.id, assignmentId);
      if (!isEnrolled) {
        return res.status(403).json({ message: 'You are not enrolled in this course' });
      }

      let fileUrl = '';
      let fileName = '';
      let content = '';
      let mimeType = null;
      let fileSize = null;
      let contentType: ContentType | null = null;

      if (submissionType === 'file' && req.file) {
        fileName = req.file.originalname;
        mimeType = req.file.mimetype;
        fileSize = req.file.size;

        const fileExtension = path.extname(fileName).slice(1).toLowerCase();
        contentType = determineContentType(mimeType, fileName);

        console.log(`User ${user.id} submission: ${fileName}, MIME: ${mimeType}, Content type: ${contentType}`);

        const isAllowed = await storage.checkFileTypeEnabled(contentType, fileExtension, mimeType);
        if (!isAllowed) {
          return res.status(400).json({
            message: `File type .${fileExtension} (${mimeType}) is not allowed`,
            details: 'This file type is currently not supported for AI evaluation'
          });
        }

        fileUrl = await storageService.storeSubmissionFile(req.file, user.id, assignmentId);

        if (contentType === 'text' && mimeType.startsWith('text/')) {
          content = req.file.buffer.toString('utf8');
        }
      } else if (submissionType === 'code') {
        content = req.body.code || '';

        if (!content.trim()) {
          return res.status(400).json({ message: 'Code content is required for code submissions' });
        }

        mimeType = 'text/plain';
        contentType = 'text' as ContentType;
        fileSize = Buffer.from(content).length;
      } else {
        return res.status(400).json({ message: 'Invalid submission type or missing file' });
      }

      const submission = await storage.createSubmission({
        assignmentId,
        userId: user.id,
        fileUrl,
        fileName,
        content,
        notes: notes || null,
        status: 'pending',
        mimeType: mimeType || null,
        fileSize: fileSize || null,
        contentType: contentType || null
      });

      submissionQueue.addSubmission(submission.id);

      res.status(201).json(submission);
  }));

  app.get('/api/submissions', requireAuth, asyncHandler(async (req: Request, res: Response) => {
      const user = req.user as any;
      const assignmentId = req.query.assignmentId ? parseInt(req.query.assignmentId as string) : undefined;

      const submissions = await storage.listSubmissionsForUser(user.id, assignmentId);

      const submissionsWithFeedback = await Promise.all(
        submissions.map(async (submission) => {
          const feedbackItem = await storage.getFeedbackBySubmissionId(submission.id);
          return {
            ...submission,
            feedback: feedbackItem
          };
        })
      );

      res.json(submissionsWithFeedback);
  }));

  app.get('/api/submissions/recent', requireAuth, asyncHandler(async (req: Request, res: Response) => {
      const user = req.user as any;

      const userSubmissions = await storage.listSubmissionsForUser(user.id);

      const recentSubmissions = userSubmissions
        .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
        .slice(0, 5);

      const submissionsWithFeedback = await Promise.all(
        recentSubmissions.map(async (submission) => {
          const feedbackItem = await storage.getFeedbackBySubmissionId(submission.id);

          return {
            ...submission,
            feedback: feedbackItem
          };
        })
      );

      res.json(submissionsWithFeedback);
  }));

  app.get('/api/assignments/:id/submissions', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      const assignmentId = parseInt(req.params.id);

      const assignment = await storage.getAssignment(assignmentId);
      if (!assignment) {
        return res.status(404).json({ message: 'Assignment not found' });
      }

      const submissions = await storage.listSubmissionsForAssignment(assignmentId);

      const submissionsWithFeedback = await Promise.all(
        submissions.map(async (submission) => {
          const feedback = await storage.getFeedbackBySubmissionId(submission.id);

          return {
            ...submission,
            feedback
          };
        })
      );

      res.json(submissionsWithFeedback);
  }));

  app.get('/api/courses', requireAuth, asyncHandler(async (req: Request, res: Response) => {
      const user = req.user as any;
      let courses;

      if (user.role === 'instructor') {
        courses = await storage.listCourses();

        courses = await Promise.all(courses.map(async (course: any) => {
          const courseAssignments = await storage.listAssignments(course.id);
          const enrolledStudents = await storage.listCourseEnrollments(course.id);

          return {
            ...course,
            assignmentCount: courseAssignments.length,
            studentCount: enrolledStudents.length
          };
        }));
      } else {
        courses = await storage.listUserEnrollments(user.id);
      }

      res.json(courses);
  }));

  app.get('/api/courses/:id', requireAuth, asyncHandler(async (req: Request, res: Response) => {
      const courseId = parseInt(req.params.id);

      if (isNaN(courseId)) {
        return res.status(400).json({ message: 'Invalid course ID' });
      }

      const course = await storage.getCourse(courseId);

      if (!course) {
        return res.status(404).json({ message: 'Course not found' });
      }

      const assignments = await storage.listAssignments(courseId);
      const enrolledStudents = await storage.listCourseEnrollments(courseId);
      const studentCount = enrolledStudents.length;

      const assignmentsWithStats = await Promise.all(
        assignments.map(async (assignment) => {
          const submissions = await storage.listSubmissionsForAssignment(assignment.id);
          const submittedCount = new Set(submissions.map(s => s.userId)).size;

          return {
            ...assignment,
            submittedCount,
            totalStudents: studentCount,
            submissionPercentage: studentCount > 0 ? (submittedCount / studentCount) * 100 : 0
          };
        })
      );

      res.json({
        ...course,
        studentCount,
        assignments: assignmentsWithStats
      });
  }));

  app.post('/api/courses', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      const { name, code, description } = req.body;

      const courseSchema = z.object({
        name: z.string().min(3),
        code: z.string().min(2),
        description: z.string().optional()
      });

      const result = courseSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: 'Invalid course data', errors: result.error });
      }

      const existingCourse = await storage.getCourseByCode(code);
      if (existingCourse) {
        return res.status(400).json({ message: 'Course code already exists' });
      }

      const course = await storage.createCourse({
        name,
        code,
        description: description || null
      });

      const testStudent = await storage.getUserByEmail('student@test.com');
      if (testStudent) {
        await storage.createEnrollment({
          userId: testStudent.id,
          courseId: course.id
        });
        console.log(`Automatically enrolled test student (ID: ${testStudent.id}) in course ${course.name}`);
      }

      res.status(201).json(course);
  }));

  app.get('/api/courses/:courseId/students', requireAuth, requireInstructor, asyncHandler(async (req: Request, res: Response) => {
      const courseId = parseInt(req.params.courseId);
      if (isNaN(courseId)) {
        return res.status(400).json({ message: 'Invalid course ID' });
      }

      const students = await storage.listCourseEnrollments(courseId);
      res.json(students);
  }));

  app.get('/api/students', requireAuth, requireInstructor, asyncHandler(async (req: Request, res: Response) => {
      const students = await storage.listStudents();
      res.json(students);
  }));

  app.get('/api/students/progress/:assignmentId?', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      let page = 1;
      const pageSize = 10;
      const searchQuery = req.query.search as string || '';
      const statusFilter = req.query.status as string || 'all';

      if (req.query.page) {
        const parsedPage = parseInt(req.query.page as string, 10);
        if (!isNaN(parsedPage) && parsedPage > 0) {
          page = parsedPage;
        }
      }

      let assignmentId: number | undefined = undefined;
      if (req.params.assignmentId) {
        const parsedId = parseInt(req.params.assignmentId, 10);
        if (!isNaN(parsedId) && parsedId > 0) {
          assignmentId = parsedId;
        } else {
          console.warn(`Invalid assignmentId format: ${req.params.assignmentId}`);
        }
      }

      let students;
      let totalCount;

      if (assignmentId) {
        const assignment = await storage.getAssignment(assignmentId);
        if (!assignment) {
          return res.status(404).json({ message: 'Assignment not found' });
        }

        const enrolledStudents = await storage.listCourseEnrollments(assignment.courseId);
        const submissions = await storage.listSubmissionsForAssignment(assignmentId);

        const submissionsByStudent = submissions.reduce((acc, submission) => {
          if (!acc[submission.userId]) {
            acc[submission.userId] = [];
          }
          acc[submission.userId].push(submission);
          return acc;
        }, {} as Record<number, any[]>);

        students = enrolledStudents.map(student => {
          const studentSubmissions = submissionsByStudent[student.id] || [];
          const latestSubmission = studentSubmissions.length > 0 ?
            studentSubmissions.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0] :
            null;

          let status: 'submitted' | 'not_submitted' | 'needs_review' = 'not_submitted';

          if (latestSubmission) {
            if (latestSubmission.status === 'completed') {
              status = 'submitted';
            } else if (['pending', 'processing'].includes(latestSubmission.status)) {
              status = 'needs_review';
            }
          }

          return {
            id: student.id,
            name: student.name,
            email: student.email,
            status,
            lastSubmission: latestSubmission ? new Date(latestSubmission.createdAt).toLocaleString() : undefined,
            attempts: studentSubmissions.length,
            submissionId: latestSubmission ? latestSubmission.id : undefined
          };
        });

        totalCount = students.length;
      } else {
        const allStudents = await db.select().from(users).where(eq(users.role, 'student'));
        totalCount = allStudents.length;

        const allSubmissions = await db.select().from(submissions);

        students = allStudents.slice((page - 1) * pageSize, page * pageSize).map((student: User) => {
          const studentSubmissions = allSubmissions.filter((sub: any) => sub.userId === student.id);
          const latestSubmission = studentSubmissions.length > 0 ?
            studentSubmissions.sort((a: any, b: any) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())[0] :
            null;

          let status: 'submitted' | 'not_submitted' | 'needs_review' = 'not_submitted';

          if (latestSubmission) {
            if (latestSubmission.status === 'completed') {
              status = 'submitted';
            } else if (['pending', 'processing'].includes(latestSubmission.status)) {
              status = 'needs_review';
            }
          }

          return {
            id: student.id,
            name: student.name,
            email: student.email,
            status,
            lastSubmission: latestSubmission ? new Date(latestSubmission.createdAt).toLocaleString() : undefined,
            attempts: studentSubmissions.length,
            submissionId: latestSubmission ? latestSubmission.id : undefined
          };
        });
      }

      if (searchQuery) {
        students = students.filter((student: { name: string; email: string }) =>
          student.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
          student.email.toLowerCase().includes(searchQuery.toLowerCase())
        );
      }

      if (statusFilter !== 'all') {
        students = students.filter((student: { status: string }) => student.status === statusFilter);
      }

      const filteredCount = students.length;
      const totalPages = Math.ceil(filteredCount / pageSize);

      const paginatedStudents = students.slice((page - 1) * pageSize, page * pageSize);

      res.json({
        students: paginatedStudents,
        totalCount: filteredCount,
        totalPages,
        currentPage: page
      });
  }));

  const { count: countFn } = await import('drizzle-orm');

  app.get('/api/assignments/stats', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      try {
      let courseId: number | undefined = undefined;
      let assignmentId: number | undefined = undefined;

      console.log("Stats query params:", req.query);

      try {
        if (req.query.courseId &&
            typeof req.query.courseId === 'string' &&
            req.query.courseId !== 'undefined' &&
            req.query.courseId !== 'null') {

          const parsedCourseId = parseInt(req.query.courseId, 10);
          if (!isNaN(parsedCourseId) && parsedCourseId > 0) {
            courseId = parsedCourseId;
            console.log("Using courseId:", courseId);
          } else {
            console.warn("Invalid courseId format:", req.query.courseId);
          }
        }

        if (req.query.assignmentId &&
            typeof req.query.assignmentId === 'string' &&
            req.query.assignmentId !== 'undefined' &&
            req.query.assignmentId !== 'null') {

          const parsedAssignmentId = parseInt(req.query.assignmentId, 10);
          if (!isNaN(parsedAssignmentId) && parsedAssignmentId > 0) {
            assignmentId = parsedAssignmentId;
            console.log("Using assignmentId:", assignmentId);
          } else {
            console.warn("Invalid assignmentId format:", req.query.assignmentId);
          }
        }
      } catch (e) {
        console.warn('Error parsing course/assignment IDs:', e);
      }

      let allAssignments = await storage.listAssignments();
      console.log(`Total assignments before filtering: ${allAssignments.length}`);

      if (courseId) {
        allAssignments = allAssignments.filter(a => a.courseId === courseId);
        console.log(`Assignments after filtering by courseId ${courseId}: ${allAssignments.length}`);
      }

      let targetAssignment = undefined;
      if (assignmentId) {
        try {
          if (typeof assignmentId === 'number' && !isNaN(assignmentId) && assignmentId > 0 && Number.isInteger(assignmentId)) {
            console.log(`Attempting to fetch assignment with ID: ${assignmentId} (type: ${typeof assignmentId})`);
            targetAssignment = await storage.getAssignment(assignmentId);
            console.log("Target assignment found:", targetAssignment ? "Yes" : "No");

            if (!targetAssignment) {
              console.warn(`Assignment with ID ${assignmentId} not found - returning default stats`);
              return res.json({
                totalStudents: 0,
                submittedCount: 0,
                notStartedCount: 0,
                submissionRate: 0,
                totalSubmissions: 0,
                pendingReviews: 0,
                averageScore: 0,
                feedbackGenerated: 0,
                feedbackViewed: 0,
                feedbackViewRate: 0,
                submissionsIncrease: 0,
                scoreDistribution: { high: 0, medium: 0, low: 0 },
                feedbackViewLast30Days: Array(30).fill(0),
                submissionsLast30Days: Array(30).fill(0),
                notStartedPercentage: 0,
                submittedPercentage: 0,
                feedbackViewPercentage: 0
              });
            }
          } else {
            console.error(`Invalid assignmentId detected: ${assignmentId}, type: ${typeof assignmentId}`);
          }
        } catch (error) {
          console.error("Error fetching target assignment:", error);
        }
      }

      let submissionsQuery = await db.select().from(submissions);

      try {
        if (assignmentId && typeof assignmentId === 'number' && !isNaN(assignmentId)) {
          console.log(`Filtering submissions by assignmentId: ${assignmentId}`);
          submissionsQuery = submissionsQuery.filter((s: any) => {
            return s && s.assignmentId === assignmentId;
          });
          console.log(`Found ${submissionsQuery.length} submissions for assignment ID ${assignmentId}`);
        } else if (courseId && typeof courseId === 'number' && !isNaN(courseId)) {
          const assignmentIds = allAssignments.map(a => a.id);
          console.log(`Filtering submissions by course-related assignments: [${assignmentIds.join(', ')}]`);

          submissionsQuery = submissionsQuery.filter((s: any) => {
            return s && s.assignmentId && assignmentIds.includes(s.assignmentId);
          });
          console.log(`Found ${submissionsQuery.length} submissions for course ID ${courseId}`);
        } else {
          console.log(`No filtering applied to submissions. Total: ${submissionsQuery.length}`);
        }
      } catch (error) {
        console.error("Error while filtering submissions:", error);
      }

      let totalStudents = 0;
      if (courseId) {
        const students = await storage.listCourseEnrollments(courseId);
        totalStudents = students.length;
        console.log(`Students enrolled in course ${courseId}: ${totalStudents}`);
      } else {
        try {
          const studentCountResult = await db.select({ count: countFn() })
            .from(users)
            .where(eq(users.role, 'student'));

          console.log("Raw student count result:", studentCountResult);

          if (studentCountResult && studentCountResult.length > 0) {
            const countValue = studentCountResult[0].count;
            if (typeof countValue === 'number') {
              totalStudents = countValue;
            } else if (typeof countValue === 'string') {
              const parsedCount = parseInt(countValue, 10);
              totalStudents = !isNaN(parsedCount) ? parsedCount : 0;
            } else if (countValue !== null && countValue !== undefined) {
               totalStudents = Number(countValue) || 0;
            }
          }
          if (isNaN(totalStudents)) totalStudents = 0;
          console.log(`Total students in system: ${totalStudents}`);
        } catch (error) {
          console.error("Error counting students:", error);
          totalStudents = 0;
        }
      }

      const totalSubmissions = submissionsQuery.length;
      console.log(`Total submissions found: ${totalSubmissions}`);

      const submittedStudentIds = new Set();
      submissionsQuery.forEach((s: any) => {
        if (s && s.userId) submittedStudentIds.add(s.userId);
      });
      const submittedCount = submittedStudentIds.size;
      console.log(`Number of unique students who submitted: ${submittedCount}`);

      const notStartedCount = Math.max(0, totalStudents - submittedCount);
      console.log(`Students who haven't started: ${notStartedCount}`);

      const submissionRate = totalStudents > 0 ? Math.round((submittedCount / totalStudents) * 100) : 0;

      const pendingReviews = submissionsQuery.filter(
        (s: { status: string }) => s.status === 'completed' // This might mean "graded", "pending review" could be different logic
      ).length;

      let feedbackItems = await db.select().from(feedback);
      if (assignmentId) {
        const submissionIds = submissionsQuery.map((s: any) => s.id);
        feedbackItems = feedbackItems.filter((f: any) => submissionIds.includes(f.submissionId));
      }

      const scores: number[] = [];
      for (const item of feedbackItems) {
        if (item.score !== null && item.score !== undefined) {
          const numericScore = Number(item.score);
          if (!isNaN(numericScore) && numericScore >= 0 && numericScore <= 100) {
            scores.push(numericScore);
          } else {
            console.warn(`Invalid score found in feedback: ${item.score}, converted to: ${numericScore}`);
          }
        }
      }

      let averageScore = 0;
      if (scores.length > 0) {
        try {
          const sum = scores.reduce((a, b) => {
            if (typeof a !== 'number' || typeof b !== 'number' || isNaN(a) || isNaN(b)) {
              console.warn(`Invalid values in score reduction: a=${a}, b=${b}`);
              return 0; // Or handle error appropriately
            }
            return a + b;
          }, 0);

          averageScore = Math.round(sum / scores.length);

          if (isNaN(averageScore) || averageScore < 0 || averageScore > 100) {
            console.warn(`Calculated average score out of bounds: ${averageScore}, resetting to 0`);
            averageScore = 0;
          }
        } catch (error) {
          console.error("Error calculating average score:", error);
          averageScore = 0;
        }
      }

      let scoreDistribution = { high: 0, medium: 0, low: 0 };
      try {
        if (scores.length > 0) {
          for (const score of scores) {
            if (score >= 80) {
              scoreDistribution.high++;
            } else if (score >= 50) {
              scoreDistribution.medium++;
            } else {
              scoreDistribution.low++;
            }
          }
          console.log("Score distribution calculated:", scoreDistribution);
        }
      } catch (error) {
        console.error("Error calculating score distribution:", error);
        scoreDistribution = { high: 0, medium: 0, low: 0 };
      }

      const feedbackGenerated = feedbackItems.length;
      const feedbackViewed = feedbackItems.filter((f: any) => f.viewed).length;
      const feedbackViewRate = feedbackGenerated > 0 ? Math.round((feedbackViewed / feedbackGenerated) * 100) : 0;

      const oneWeekAgo = new Date();
      oneWeekAgo.setDate(oneWeekAgo.getDate() - 7);

      const submissionsLastWeek = submissionsQuery.filter(
        (s: { createdAt: string | Date }) => new Date(s.createdAt) >= oneWeekAgo
      ).length;

      const previousWeekStart = new Date(oneWeekAgo);
      previousWeekStart.setDate(previousWeekStart.getDate() - 7);

      const submissionsPreviousWeek = submissionsQuery.filter(
        (s: { createdAt: string | Date }) => new Date(s.createdAt) >= previousWeekStart && new Date(s.createdAt) < oneWeekAgo
      ).length;

      const submissionsIncrease = submissionsPreviousWeek > 0
        ? Math.round((submissionsLastWeek - submissionsPreviousWeek) / submissionsPreviousWeek * 100)
        : (submissionsLastWeek > 0 ? 100 : 0); // If prev week was 0, any submission is an "infinite" or 100% increase

      res.json({
        totalStudents,
        submittedCount,
        notStartedCount,
        submissionRate,
        totalSubmissions,
        pendingReviews,
        averageScore,
        feedbackGenerated,
        feedbackViewed,
        feedbackViewRate,
        submissionsIncrease,
        scoreDistribution,
        submittedPercentage: submissionRate,
        notStartedPercentage: totalStudents > 0 ? Math.round((notStartedCount / totalStudents) * 100) : 0,
        feedbackViewPercentage: feedbackViewRate
      });
      } catch (error) {
        console.error("Error in /api/assignments/stats:", error);
        // Return a default stats object in case of any unhandled error in the try block
        return res.json({
          totalStudents: 0,
          submittedCount: 0,
          notStartedCount: 0,
          submissionRate: 0,
          totalSubmissions: 0,
          pendingReviews: 0,
          averageScore: 0,
          feedbackGenerated: 0,
          feedbackViewed: 0,
          feedbackViewRate: 0,
          submissionsIncrease: 0,
          scoreDistribution: { high: 0, medium: 0, low: 0 },
          feedbackViewLast30Days: Array(30).fill(0), // These fields were in original, keeping for consistency
          submissionsLast30Days: Array(30).fill(0), // These fields were in original, keeping for consistency
          notStartedPercentage: 0,
          submittedPercentage: 0,
          feedbackViewPercentage: 0
        });
      }
  }));

  app.get('/api/assignments/:id?/analytics', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      let assignmentId: number | undefined = undefined;
      if (req.params.id) {
        const parsed = parseInt(req.params.id, 10);
        if (!isNaN(parsed) && parsed > 0) {
          assignmentId = parsed;
        } else {
          console.warn("Invalid assignment ID format:", req.params.id);
        }
      }

      let targetAssignmentId = assignmentId;

      if (!targetAssignmentId) {
        const activeAssignments = (await storage.listAssignments())
          .filter(a => a.status === 'active')
          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

        if (activeAssignments.length === 0) {
          return res.status(404).json({ message: 'No active assignments found' });
        }

        targetAssignmentId = activeAssignments[0].id;
      }

      const assignment = await storage.getAssignment(targetAssignmentId);
      if (!assignment) {
        return res.status(404).json({ message: 'Assignment not found' });
      }

      const submissions = await storage.listSubmissionsForAssignment(targetAssignmentId);
      const students = await storage.listCourseEnrollments(assignment.courseId);
      const totalStudents = students.length;

      const submittedStudentIds = new Set(submissions.map(s => s.userId));
      const submittedCount = submittedStudentIds.size;

      const inProgressStudents = new Map();

      for (const submission of submissions) {
        if (!inProgressStudents.has(submission.userId) ||
            new Date(submission.createdAt) > new Date(inProgressStudents.get(submission.userId).createdAt)) {
          inProgressStudents.set(submission.userId, submission);
        }
      }

      const inProgressCount = Array.from(inProgressStudents.values()).filter(
        s => s.status === 'pending' || s.status === 'processing'
      ).length;

      const notStartedCount = totalStudents - submittedCount;

      const timeline = [];
      const today = new Date();

      for (let i = 6; i >= 0; i--) {
        const date = new Date(today);
        date.setDate(date.getDate() - i);
        date.setHours(0, 0, 0, 0);

        const nextDate = new Date(date);
        nextDate.setDate(nextDate.getDate() + 1);

        const count = submissions.filter(
          s => new Date(s.createdAt) >= date && new Date(s.createdAt) < nextDate
        ).length;

        timeline.push({
          date: date.toISOString().split('T')[0],
          count
        });
      }

      const feedbackItems = await Promise.all(
        submissions.map(s => storage.getFeedbackBySubmissionId(s.id))
      );

      const validFeedback = feedbackItems.filter(f => f !== undefined) as any[];

      const avgFeedbackTime = validFeedback.length > 0
        ? Math.round(validFeedback.reduce((sum, f) => sum + (f.processingTime || 0), 0) / validFeedback.length / 1000) // Added fallback for processingTime
        : 0;

      const submissionsByStudent = submissions.reduce((acc, sub) => {
        if (!acc[sub.userId]) acc[sub.userId] = [];
        acc[sub.userId].push(sub);
        return acc;
      }, {} as Record<number, any[]>);

      const revisionsPerStudent = Object.values(submissionsByStudent)
        .map(subs => subs.length);

      const avgRevisionsPerStudent = revisionsPerStudent.length > 0
        ? revisionsPerStudent.reduce((sum, count) => sum + count, 0) / revisionsPerStudent.length
        : 0;

      const avgImprovementPercentage = 18; // This seems like a placeholder

      res.json({
        assignmentStats: {
          submittedCount,
          inProgressCount,
          notStartedCount,
          totalCount: totalStudents,
          submissionPercentage: totalStudents > 0 ? (submittedCount / totalStudents) * 100 : 0
        },
        submissionTimeline: timeline,
        avgFeedbackTime,
        avgRevisionsPerStudent,
        avgImprovementPercentage
      });
  }));

  app.post('/api/test-rubric', requireAuth, requireRole('instructor'),
    upload.single('file'),
    asyncHandler(async (req: Request, res: Response) => {
      let content = req.body.content;
      const { assignmentContext } = req.body;
      let file = req.file;

      if (!content && !file) {
        return res.status(400).json({ message: 'Content or file is required' });
      }

      const aiService = new AIService(new GeminiAdapter()); // Consider making AI adapter configurable

      try {
        let feedback;

        if (file) {
          const isImage = file.mimetype.startsWith('image/');
          const isDocument = file.mimetype.includes('pdf') ||
                               file.mimetype.includes('word') || // More specific mimetypes are better
                               file.mimetype.includes('doc'); // 'application/msword', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document'

          if (isImage) {
            console.log(`Processing image file: ${file.originalname} (${file.mimetype}), buffer size: ${file.buffer.length} bytes`);

            try {
              const isSmallImage = file.buffer.length < 5 * 1024 * 1024; // Configurable limit?
              const imageDataUri = isSmallImage
                ? `data:${file.mimetype};base64,${file.buffer.toString('base64')}`
                : undefined;

              console.log(`Using ${isSmallImage ? 'data URI' : 'buffer'} for image processing`);

              feedback = await aiService.analyzeMultimodalSubmission({
                fileBuffer: file.buffer,
                fileDataUri: imageDataUri,
                fileName: file.originalname,
                mimeType: file.mimetype,
                assignmentTitle: "Image Analysis", // Generic title
                assignmentDescription: assignmentContext || "Please analyze this image submission."
              });
            } catch (error: any) {
              console.error(`Error analyzing image: ${error.message || 'Unknown error'}`, error);
              return res.status(500).json({
                error: "Failed to analyze image",
                message: error.message || 'Unknown error',
                // Providing structured feedback on error might be helpful
                strengths: ["We encountered an error analyzing your image."],
                improvements: ["Please try a different image or a text submission."],
                suggestions: ["Make sure your image is a standard format (JPEG, PNG, etc)."],
                summary: "There was an error processing your image submission. For best results, try using a standard image format under 5MB."
              });
            }
          } else if (isDocument) {
            console.log(`Processing document file: ${file.originalname} (${file.mimetype}), buffer size: ${file.buffer.length} bytes`);

            try {
              feedback = await aiService.analyzeMultimodalSubmission({
                fileBuffer: file.buffer,
                fileName: file.originalname,
                mimeType: file.mimetype,
                assignmentTitle: "Document Analysis", // Generic title
                assignmentDescription: assignmentContext || "Please analyze this document submission."
              });
            } catch (error: any) {
              console.error(`Error analyzing document: ${error.message || 'Unknown error'}`, error);
              return res.status(500).json({
                error: "Failed to analyze document",
                message: error.message || 'Unknown error',
                strengths: ["We encountered an error analyzing your document."],
                improvements: ["Please try a different document format or a text submission."],
                suggestions: ["Make sure your document is a standard format (PDF, DOCX, etc)."],
                summary: "There was an error processing your document. For best results, try using a standard document format like PDF or DOCX under 5MB."
              });
            }
          } else { // Fallback for other file types or if content needs to be extracted
            if (!content && file.path) { // multer might save to disk if memoryStorage isn't used or if it's large
              content = fs.readFileSync(file.path, 'utf8'); // This assumes file.path is set, memoryStorage usually doesn't
            } else if (!content && file.buffer) {
                content = file.buffer.toString('utf8'); // If it's a text-based file in buffer
            }


            feedback = await aiService.analyzeProgrammingAssignment({
              content: content || "", // Ensure content is not undefined
              assignmentContext
            });
          }
        } else { // Only text content provided
          feedback = await aiService.analyzeProgrammingAssignment({
            content: content || "", // Ensure content is not undefined
            assignmentContext
          });
        }

        console.log("AI feedback generated successfully:", JSON.stringify(feedback).slice(0, 200) + "...");

        if (file && file.path && fs.existsSync(file.path)) { // Check if path exists before unlinking
          fs.unlink(file.path, (err: NodeJS.ErrnoException | null) => {
            if (err) console.error("Error removing temporary file:", err);
          });
        }

        return res.json({
          strengths: feedback.strengths,
          improvements: feedback.improvements,
          suggestions: feedback.suggestions,
          summary: feedback.summary,
          score: feedback.score
        });
      } catch (error) {
        console.error("Error generating AI feedback:", error);

        if (file && file.path && fs.existsSync(file.path)) { // Check if path exists
          fs.unlink(file.path, (err: NodeJS.ErrnoException | null) => {
            if (err) console.error("Error removing temporary file:", err);
          });
        }

        return res.status(500).json({
          message: 'Failed to generate AI feedback',
          error: error instanceof Error ? error.message : String(error)
        });
      }
  }));

  app.get('/api/export/grades', requireAuth, requireRole('instructor'), asyncHandler(async (req: Request, res: Response) => {
      const assignmentIdStr = req.query.assignmentId as string;
      if (!assignmentIdStr) {
        return res.status(400).json({ message: 'Assignment ID is required' });
      }
      const assignmentId = parseInt(assignmentIdStr);


      if (isNaN(assignmentId)) {
        return res.status(400).json({ message: 'Invalid Assignment ID format' });
      }

      const assignment = await storage.getAssignment(assignmentId);
      if (!assignment) {
        return res.status(404).json({ message: 'Assignment not found' });
      }

      const course = await storage.getCourse(assignment.courseId);
      if (!course) {
        return res.status(404).json({ message: 'Course not found for this assignment' });
      }

      const students = await storage.listCourseEnrollments(assignment.courseId);
      const submissions = await storage.listSubmissionsForAssignment(assignmentId);

      const submissionsByStudent = submissions.reduce((acc, sub) => {
        if (!acc[sub.userId]) acc[sub.userId] = [];
        acc[sub.userId].push(sub);
        return acc;
      }, {} as Record<number, any[]>);

      const feedbackPromises = submissions.map(s => storage.getFeedbackBySubmissionId(s.id));
      const allFeedback = await Promise.all(feedbackPromises);

      const feedbackBySubmission = new Map();
      allFeedback.filter(Boolean).forEach(f => {
        if (f) { // Ensure f is not null or undefined
          feedbackBySubmission.set(f.submissionId, f);
        }
      });

      let csv = 'Student ID,Student Name,Student Email,Submission Status,Submission Date,Last Score,Attempts,Feedback Summary\n';

      for (const student of students) {
        const studentSubmissions = submissionsByStudent[student.id] || [];

        studentSubmissions.sort((a, b) =>
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );

        const latestSubmission = studentSubmissions[0];

        let status = 'Not Submitted';
        let submissionDate = '';
        let score = '';
        let attempts = studentSubmissions.length.toString();
        let feedbackSummary = '';

        if (latestSubmission) {
          status = latestSubmission.status === 'completed' ? 'Completed' :
                   latestSubmission.status === 'processing' ? 'Processing' :
                   latestSubmission.status === 'pending' ? 'Pending' : 'Failed'; // Consider other statuses

          submissionDate = new Date(latestSubmission.createdAt).toLocaleString();

          const feedbackForLatest = feedbackBySubmission.get(latestSubmission.id);
          if (feedbackForLatest) {
            score = feedbackForLatest.score !== null ? feedbackForLatest.score.toString() : '';
            feedbackSummary = feedbackForLatest.summary ? feedbackForLatest.summary.replace(/"/g, '""') : ''; // Handle null summary
          }
        }

        csv += `${student.id},"${student.name}","${student.email}","${status}","${submissionDate}","${score}","${attempts}","${feedbackSummary}"\n`;
      }

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', `attachment; filename="${course.code}_${assignment.title.replace(/\s+/g, '_')}_grades.csv"`);

      res.send(csv);
  }));

  const httpServer = createServer(app);

  return httpServer;
}