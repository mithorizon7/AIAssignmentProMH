# Gemini API Parts and Content

This document covers the Parts and Content resources used in the Gemini API, particularly for creating multi-part content in requests and handling responses.

## Resource: Content

The base structured datatype containing multi-part content of a message.

A Content includes a role field designating the producer of the Content and a parts field containing multi-part data that constitutes the content of the message turn.

**Fields**

- **parts[]**: object ([Part](#resource-part))
  - Ordered Parts that constitute a single message. Parts may have different MIME types.

- **role**: string
  - Optional. The producer of the content. Must be either 'user' or 'model'.
  - Useful to set for multi-turn conversations, otherwise can be left blank or unset.

**JSON representation**

```json
{
  "parts": [
    {
      object (Part)
    }
  ],
  "role": string
}
```

## Resource: Part

A datatype containing media that is part of a multi-part Content message.

A Part consists of data which has an associated datatype. A Part can only contain one of the accepted types in Part.data.

A Part must have a fixed IANA MIME type identifying the type and subtype of the media if the inlineData field is filled with raw bytes.

**Fields**

- **thought**: boolean
  - Optional. Indicates if the part is a thought from the model.

- **data**: Union type
  - data can be only one of the following:

  - **text**: string
    - Inline text.

  - **inlineData**: object ([Blob](#resource-blob))
    - Inline media bytes.

  - **functionCall**: object ([FunctionCall](#resource-functioncall))
    - A predicted FunctionCall returned from the model that contains a string representing the FunctionDeclaration.name with the arguments and their values.

  - **functionResponse**: object ([FunctionResponse](#resource-functionresponse))
    - The result output of a FunctionCall that contains a string representing the FunctionDeclaration.name and a structured JSON object containing any output from the function is used as context to the model.

  - **fileData**: object ([FileData](#resource-filedata))
    - URI based data.

  - **executableCode**: object ([ExecutableCode](#resource-executablecode))
    - Code generated by the model that is meant to be executed.

  - **codeExecutionResult**: object ([CodeExecutionResult](#resource-codeexecutionresult))
    - Result of executing the ExecutableCode.

**JSON representation**

```json
{
  "thought": boolean,

  // data
  "text": string,
  "inlineData": {
    object (Blob)
  },
  "functionCall": {
    object (FunctionCall)
  },
  "functionResponse": {
    object (FunctionResponse)
  },
  "fileData": {
    object (FileData)
  },
  "executableCode": {
    object (ExecutableCode)
  },
  "codeExecutionResult": {
    object (CodeExecutionResult)
  }
  // Union type
}
```

## Resource: Blob

Raw media bytes. Text should not be sent as raw bytes, use the 'text' field.

**Fields**

- **mimeType**: string
  - The IANA standard MIME type of the source data. Examples: 
    - image/png
    - image/jpeg
  - If an unsupported MIME type is provided, an error will be returned. For a complete list of supported types, see Supported file formats.

- **data**: string (bytes format)
  - Raw bytes for media formats.
  - A base64-encoded string.

**JSON representation**

```json
{
  "mimeType": string,
  "data": string
}
```

## Resource: FileData

Reference to a file in the system.

**Fields**

- **fileUri**: string
  - Required. URI of file.

- **mimeType**: string
  - Required. MIME type of the file.

**JSON representation**

```json
{
  "fileUri": string,
  "mimeType": string
}
```

## Resource: ContentPair

A pair of contents used by the model to answer a query.

**Fields**

- **content**: object ([Content](#resource-content))
  - Required. A single part query.

- **response**: object ([Content](#resource-content))
  - Required. A single part response corresponding to the query.

**JSON representation**

```json
{
  "content": {
    object (Content)
  },
  "response": {
    object (Content)
  }
}
```

## JavaScript Usage Examples

### Creating Content with Text Parts

```javascript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

// Simple text part
const contents = [{ text: "Write a poem about programming" }];

const response = await ai.models.generateContent({
  model: "gemini-2.0-flash",
  contents: contents
});

console.log(response.text);
```

### Creating Content with Multiple Parts

```javascript
import { GoogleGenAI } from "@google/genai";
import * as fs from "node:fs";

const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

// Multiple parts - text and image
const imageBase64 = fs.readFileSync("path/to/image.jpg", {
  encoding: "base64",
});

const contents = [
  { text: "Describe this image in detail:" },
  {
    inlineData: {
      mimeType: "image/jpeg",
      data: imageBase64,
    },
  }
];

const response = await ai.models.generateContent({
  model: "gemini-2.0-flash",
  contents: contents
});

console.log(response.text);
```

### Using Roles in Multi-turn Conversations

```javascript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

// For multi-turn conversations, use the chats API with roles
const chat = ai.chats.create({
  model: "gemini-2.0-flash",
  history: [
    {
      role: "user",
      parts: [{ text: "Hello, I'm learning about programming languages" }]
    },
    {
      role: "model",
      parts: [{ text: "That's great! What would you like to know about programming languages?" }]
    }
  ]
});

const response = await chat.sendMessage({
  message: "Can you compare Python and JavaScript for beginners?",
});

console.log(response.text);
```