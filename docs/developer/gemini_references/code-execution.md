# Code Execution in Gemini API

This document covers the code execution capabilities in the Gemini API, which allows the model to generate executable code and process the results of code execution.

## Resource: ExecutableCode

Represents code generated by the model that is meant to be executed.

**Fields**

- **language**: string
  - Required. The programming language the code is written in (e.g., "python", "javascript").

- **code**: string
  - Required. The code to execute.

**JSON representation**

```json
{
  "language": string,
  "code": string
}
```

## Resource: CodeExecutionResult

Represents the result of executing code.

**Fields**

- **output**: string
  - Optional. The output from the code execution. This could be the STDOUT or a combination of STDOUT and STDERR.

- **executionError**: string
  - Optional. Error that occurred during the execution of the code.

**JSON representation**

```json
{
  "output": string,
  "executionError": string
}
```

## JavaScript Usage Examples

### Using Code Generation

```javascript
import { GoogleGenAI } from "@google/genai";

const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

async function generateAndExecuteCode() {
  const model = ai.models.getGenerativeModel({
    model: "gemini-2.0-flash"
  });

  // Ask the model to generate code
  const result = await model.generateContent({
    contents: [{ 
      text: "Write a Python function to calculate the Fibonacci sequence up to n terms" 
    }]
  });

  // Extract and print the response
  console.log(result.text);
}

generateAndExecuteCode();
```

### Code Execution with Feedback Loop

```javascript
import { GoogleGenAI } from "@google/genai";
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";

const execPromise = promisify(exec);
const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

async function codeExecutionLoop() {
  const model = ai.models.getGenerativeModel({
    model: "gemini-2.0-flash"
  });

  const chat = model.startChat();
  
  // Initial request for code
  const initialResponse = await chat.sendMessage({
    text: "Write a Python function that sorts a list of integers in descending order. Include a test case."
  });
  
  console.log("Generated code:");
  console.log(initialResponse.text);
  
  // Extract the Python code (in a real app, you'd use better parsing)
  const codeMatch = initialResponse.text.match(/```python\n([\s\S]*?)```/);
  
  if (codeMatch && codeMatch[1]) {
    const code = codeMatch[1];
    
    // Write the code to a temporary file
    await fs.writeFile("temp_code.py", code);
    
    try {
      // Execute the Python code
      const { stdout, stderr } = await execPromise("python3 temp_code.py");
      
      console.log("\nExecution result:");
      console.log(stdout);
      
      if (stderr) {
        console.log("Errors:");
        console.log(stderr);
        
        // If there was an error, send it back to the model for correction
        const fixResponse = await chat.sendMessage({
          text: `There was an error running your code:\n${stderr}\nPlease fix it and provide the corrected version.`
        });
        
        console.log("\nFixed code:");
        console.log(fixResponse.text);
      }
      
      // Clean up
      await fs.unlink("temp_code.py");
      
    } catch (error) {
      console.error("Execution error:", error.message);
      
      // Send error to model for correction
      const fixResponse = await chat.sendMessage({
        text: `There was an error running your code:\n${error.message}\nPlease fix it and provide the corrected version.`
      });
      
      console.log("\nFixed code:");
      console.log(fixResponse.text);
      
      // Clean up
      await fs.unlink("temp_code.py").catch(() => {});
    }
  }
}

codeExecutionLoop();
```

### Using Part-based Code Execution

```javascript
import { GoogleGenAI } from "@google/genai";
import { exec } from "child_process";
import { promisify } from "util";
import * as fs from "fs/promises";

const execPromise = promisify(exec);
const ai = new GoogleGenAI({ apiKey: "GEMINI_API_KEY" });

// This example demonstrates how code execution will work with future versions
// of the Gemini API that directly support code execution parts
async function simulatedCodeExecutionWithParts() {
  const model = ai.models.getGenerativeModel({
    model: "gemini-2.0-flash"
  });

  const chat = model.startChat();
  
  // Initial request for code
  const initialResponse = await chat.sendMessage({
    text: "Write a JavaScript function to check if a string is a palindrome"
  });
  
  // In future implementations, the model might return an executableCode part directly
  // For now, we'll simulate this by extracting the code from the text response
  const codeMatch = initialResponse.text.match(/```javascript\n([\s\S]*?)```/);
  
  if (codeMatch && codeMatch[1]) {
    const code = codeMatch[1];
    
    // Create a simulated executable code part
    const executableCodePart = {
      executableCode: {
        language: "javascript",
        code: code
      }
    };
    
    console.log("Generated code part:", executableCodePart);
    
    // Write the code to a temporary file
    await fs.writeFile("temp_code.js", code);
    
    try {
      // Execute the JavaScript code 
      const { stdout, stderr } = await execPromise("node temp_code.js");
      
      // Create a simulated code execution result
      const codeExecutionResultPart = {
        codeExecutionResult: {
          output: stdout,
          executionError: stderr || null
        }
      };
      
      console.log("Execution result part:", codeExecutionResultPart);
      
      // In a future implementation, you would send this back to the model
      // chat.sendMessage({ parts: [codeExecutionResultPart] });
      
      // For now, we'll just send the result as text
      const finalResponse = await chat.sendMessage({
        text: `I executed your code and here's the result:\n${stdout}${stderr ? '\nErrors: ' + stderr : ''}`
      });
      
      console.log("Final model response:", finalResponse.text);
      
      // Clean up
      await fs.unlink("temp_code.js");
      
    } catch (error) {
      console.error("Execution error:", error.message);
      
      // Clean up
      await fs.unlink("temp_code.js").catch(() => {});
    }
  }
}

simulatedCodeExecutionWithParts();
```

## Best Practices for Code Execution

1. **Security Considerations**
   - Never execute untrusted code in an uncontrolled environment
   - Consider using sandboxed environments like Docker containers for code execution
   - Limit execution time and resource usage

2. **Error Handling**
   - Always implement proper error handling for code execution
   - Provide clear feedback on execution errors to the model for correction

3. **Language Support**
   - Verify that your environment has the necessary interpreters/compilers installed
   - For web applications, consider client-side execution for JavaScript code

4. **Execution Chain**
   - Use a multi-turn conversation approach for iterative improvement of code
   - Provide context from previous executions to help the model refine its outputs