Performance & Scalability Readiness

Design for Scale: The application is intended to scale to “tens of thousands of students”
GitHub
, which is ambitious. The architecture includes elements to support scale: a BullMQ Redis-backed queue for offloading work, use of PostgreSQL (which can handle large data volumes with proper indexing), and separation of front/back-end allowing horizontal scaling of the Node.js server processes
GitHub
. To realize this potential, the following performance considerations must be addressed:
Re-enable Async Processing (High ⚠️): As emphasized, getting BullMQ working is critical for scalability. Synchronous processing of every submission will not hold up under high load. Once the queue is active with a single Redis client, the app can distribute grading tasks to background workers, preventing request latency from ballooning. Recommendation: Treat the BullMQ restoration as a top performance priority. After re-enabling it, conduct stress tests: e.g. simulate a large batch of submissions (hundreds or thousands) arriving in a short time. Observe that they queue up and get processed in a timely manner without crashing the server. Monitor memory and CPU during this process to ensure the Node.js process (and the worker process) handle the load. If needed, one can scale by running multiple worker processes – BullMQ can have many workers consuming jobs from Redis. The system should be configured such that if load increases, you can add more worker dynos/pods to speed up processing.
Database Migrations & Indexing (High ⚠️): Performance at scale often hinges on the database. The pending LMS migration likely adds new tables and indexes – those indexes are essential for query speed. The note to separate index creation queries
GitHub
 suggests that indices were planned. Recommendation: Ensure that all key database indexes are in place (especially on columns used for lookups or joins, like user IDs, assignment IDs, foreign keys, etc.). After running migrations, double-check the DB schema for any missing indexes. For example, if there’s a table tracking submissions, it should have an index on assignmentId or userId for fast retrieval of a subset of submissions. Run Drizzle’s schema sync and consider adding migrations for any performance-critical indexes that aren’t yet defined. This will support quick queries even as data volume grows.
